nextflow.enable.dsl = 2

params.RNAseq_samplesheet = false
params.protein_samplesheet = false
params.new_assembly = false
params.previous_assembly = false
params.previous_annotations = false
params.output_dir = false

if (!params.output_dir || !params.RNAseq_samplesheet || !params.protein_samplesheet || !params.new_assembly || !params.previous_assembly || !params.previous_annotations) {
    error "Missing required parameters. Please provide values for: output_dir, RNAseq_samplesheet, protein_samplesheet, new_assembly, previous_assembly, previous_annotations"
}

// Include subworkflows
include { generate_evidence_data } from './subworkflows/generate_evidence_data'
include { aegis } from './subworkflows/aegis'

// Define the output directory for intermediate files
params.workflow = params.workflow ?: "all"  // default = "all"

// Define Channels
Channel.fromPath(file(params.RNAseq_samplesheet))
       .splitCsv(header: true, sep: ',')
       .filter( ~/.*long.*/ )
       .map { row -> [ row.sampleID, row.SRA_or_FASTQ, row.library_layout ] }
       .set{ samples_list_long_reads }


Channel.fromPath(file(params.RNAseq_samplesheet))
       .splitCsv(header: true, sep: ',')
       .filter( ~/.*single.*/ )
       .map { row -> [ row.sampleID, row.SRA_or_FASTQ, row.library_layout ] }
       .set{ samples_list_single_short_reads }


Channel.fromPath(file(params.RNAseq_samplesheet))
       .splitCsv(header: true, sep: ',')
       .filter( ~/.*paired.*/ )
       .map { row -> [ row.sampleID, row.SRA_or_FASTQ, row.library_layout ] }
       .set{ samples_list_paired_short_reads }

// Combined single and paired-end reads
samples_list_single_short_reads
    .concat(samples_list_paired_short_reads)
    .set { samples_list_short_reads }

Channel.fromPath(file(params.protein_samplesheet))
       .splitCsv(header: true, sep: ',')
       .map { row -> [ row.organism, row.filename ] }
       .set{ protein_list }

workflow {
    // if the workflow parameter is equal to generate_evidence_data or all, the first workflow is executed
    if (params.workflow == "generate_evidence_data" || params.workflow == "all") {
        evidence_data = generate_evidence_data(
            samples_list_long_reads, 
            samples_list_short_reads, 
            protein_list
        )
        
        if (params.workflow == "all") {
            aegis(evidence_data.results)
        }
    }
    
    // if the workflow parameter is equal to aegis, the outputs generated by the first workflow (generate_evidence_data) must be retrieved manually.
    else if (params.workflow == "aegis") {

      def outdir_1 = params.output_dir
      def workflow_inputs = Channel.empty()

      // Load manually the outputs of generate_evidence_data workflow
      if (params.EDTA == 'yes') {
        workflow_inputs = workflow_inputs.mix(
          Channel.fromPath("${outdir_1}/assembly_masked.EDTA.fasta")
            .map { f -> tuple("masked_genome.masked_genome", f) }
          )
      }

      if (params.use_long_reads) {
        workflow_inputs = workflow_inputs.mix(
          Channel.fromPath("${outdir_1}/merged_minimap2_stringtie_long_reads_default.gtf")
            .map { f -> tuple("merged_long_reads.default_args_gff", f) },
          Channel.fromPath("${outdir_1}/merged_minimap2_stringtie_long_reads_alt.gtf")
            .map { f -> tuple("merged_long_reads.alt_args_gff", f) }
        )
      }

      workflow_inputs = workflow_inputs.mix(
        Channel.fromPath("${outdir_1}/augustus.hints.gff3")
          .map { f -> tuple("braker3_results.augustus_gff", f) },
        Channel.fromPath("${outdir_1}/genemark.gtf")
          .map { f -> tuple("braker3_results.genemark_gtf", f) },
        Channel.fromPath("${outdir_1}/liftoff_previous_annotations.gff3")
          .map { f -> tuple("previous_annotations.liftoff_previous_annotations", f) },
        Channel.fromPath("${outdir_1}/merged_star_stringtie_stranded_default.gtf")
          .map { f -> tuple("merged_star_stringtie.default_args_stranded", f) },
        Channel.fromPath("${outdir_1}/merged_star_stringtie_stranded_alt.gtf")
          .map { f -> tuple("merged_star_stringtie.alt_args_stranded", f) },
        Channel.fromPath("${outdir_1}/merged_star_psiclass_stranded.gtf")
          .map { f -> tuple("gffcompare_out.star_psiclass_stranded", f) },
        Channel.fromPath("${outdir_1}/merged_star_stringtie_unstranded_default.gtf")
          .map { f -> tuple("merged_star_stringtie.default_args_unstranded", f) },
        Channel.fromPath("${outdir_1}/merged_star_stringtie_unstranded_alt.gtf")
          .map { f -> tuple("merged_star_stringtie.alt_args_unstranded", f) },
        Channel.fromPath("${outdir_1}/merged_star_psiclass_unstranded.gtf")
          .map { f -> tuple("gffcompare_out.star_psiclass_unstranded", f) }
    )

    aegis(workflow_inputs.collect())
  }
}
